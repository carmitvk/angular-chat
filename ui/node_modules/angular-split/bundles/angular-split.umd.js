(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('angular-split', ['exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['angular-split'] = {}, global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators));
}(this, (function (exports, core, common, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} event
     * @return {?}
     */
    function getPointFromEvent(event) {
        // TouchEvent
        if ((( /** @type {?} */(event))).changedTouches !== undefined && (( /** @type {?} */(event))).changedTouches.length > 0) {
            return {
                x: (( /** @type {?} */(event))).changedTouches[0].clientX,
                y: (( /** @type {?} */(event))).changedTouches[0].clientY,
            };
        }
        // MouseEvent
        else if ((( /** @type {?} */(event))).clientX !== undefined && (( /** @type {?} */(event))).clientY !== undefined) {
            return {
                x: (( /** @type {?} */(event))).clientX,
                y: (( /** @type {?} */(event))).clientY,
            };
        }
        return null;
    }
    /**
     * @param {?} elRef
     * @param {?} direction
     * @return {?}
     */
    function getElementPixelSize(elRef, direction) {
        /** @type {?} */
        var rect = (( /** @type {?} */(elRef.nativeElement))).getBoundingClientRect();
        return direction === 'horizontal' ? rect.width : rect.height;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    function getInputBoolean(v) {
        return typeof v === 'boolean' ? v : v === 'false' ? false : true;
    }
    /**
     * @template T
     * @param {?} v
     * @param {?} defaultValue
     * @return {?}
     */
    function getInputPositiveNumber(v, defaultValue) {
        if (v === null || v === undefined)
            return defaultValue;
        v = Number(v);
        return !isNaN(v) && v >= 0 ? v : defaultValue;
    }
    /**
     * @param {?} unit
     * @param {?} sizes
     * @return {?}
     */
    function isUserSizesValid(unit, sizes) {
        // All sizes have to be not null and total should be 100
        if (unit === 'percent') {
            /** @type {?} */
            var total = sizes.reduce(( /**
             * @param {?} total
             * @param {?} s
             * @return {?}
             */function (total, s) { return (s !== null ? total + s : total); }), 0);
            return sizes.every(( /**
             * @param {?} s
             * @return {?}
             */function (s) { return s !== null; })) && total > 99.9 && total < 100.1;
        }
        // A size at null is mandatory but only one.
        if (unit === 'pixel') {
            return sizes.filter(( /**
             * @param {?} s
             * @return {?}
             */function (s) { return s === null; })).length === 1;
        }
    }
    /**
     * @param {?} a
     * @return {?}
     */
    function getAreaMinSize(a) {
        if (a.size === null) {
            return null;
        }
        if (a.component.lockSize === true) {
            return a.size;
        }
        if (a.component.minSize === null) {
            return null;
        }
        if (a.component.minSize > a.size) {
            return a.size;
        }
        return a.component.minSize;
    }
    /**
     * @param {?} a
     * @return {?}
     */
    function getAreaMaxSize(a) {
        if (a.size === null) {
            return null;
        }
        if (a.component.lockSize === true) {
            return a.size;
        }
        if (a.component.maxSize === null) {
            return null;
        }
        if (a.component.maxSize < a.size) {
            return a.size;
        }
        return a.component.maxSize;
    }
    /**
     * @param {?} unit
     * @param {?} sideAreas
     * @param {?} pixels
     * @param {?} allAreasSizePixel
     * @return {?}
     */
    function getGutterSideAbsorptionCapacity(unit, sideAreas, pixels, allAreasSizePixel) {
        return sideAreas.reduce(( /**
         * @param {?} acc
         * @param {?} area
         * @return {?}
         */function (acc, area) {
            /** @type {?} */
            var res = getAreaAbsorptionCapacity(unit, area, acc.remain, allAreasSizePixel);
            acc.list.push(res);
            acc.remain = res.pixelRemain;
            return acc;
        }), { remain: pixels, list: [] });
    }
    /**
     * @param {?} unit
     * @param {?} areaSnapshot
     * @param {?} pixels
     * @param {?} allAreasSizePixel
     * @return {?}
     */
    function getAreaAbsorptionCapacity(unit, areaSnapshot, pixels, allAreasSizePixel) {
        // No pain no gain
        if (pixels === 0) {
            return {
                areaSnapshot: areaSnapshot,
                pixelAbsorb: 0,
                percentAfterAbsorption: areaSnapshot.sizePercentAtStart,
                pixelRemain: 0,
            };
        }
        // Area start at zero and need to be reduced, not possible
        if (areaSnapshot.sizePixelAtStart === 0 && pixels < 0) {
            return {
                areaSnapshot: areaSnapshot,
                pixelAbsorb: 0,
                percentAfterAbsorption: 0,
                pixelRemain: pixels,
            };
        }
        if (unit === 'percent') {
            return getAreaAbsorptionCapacityPercent(areaSnapshot, pixels, allAreasSizePixel);
        }
        if (unit === 'pixel') {
            return getAreaAbsorptionCapacityPixel(areaSnapshot, pixels, allAreasSizePixel);
        }
    }
    /**
     * @param {?} areaSnapshot
     * @param {?} pixels
     * @param {?} allAreasSizePixel
     * @return {?}
     */
    function getAreaAbsorptionCapacityPercent(areaSnapshot, pixels, allAreasSizePixel) {
        /** @type {?} */
        var tempPixelSize = areaSnapshot.sizePixelAtStart + pixels;
        /** @type {?} */
        var tempPercentSize = (tempPixelSize / allAreasSizePixel) * 100;
        // ENLARGE AREA
        if (pixels > 0) {
            // If maxSize & newSize bigger than it > absorb to max and return remaining pixels
            if (areaSnapshot.area.maxSize !== null && tempPercentSize > areaSnapshot.area.maxSize) {
                // Use area.area.maxSize as newPercentSize and return calculate pixels remaining
                /** @type {?} */
                var maxSizePixel = (areaSnapshot.area.maxSize / 100) * allAreasSizePixel;
                return {
                    areaSnapshot: areaSnapshot,
                    pixelAbsorb: maxSizePixel,
                    percentAfterAbsorption: areaSnapshot.area.maxSize,
                    pixelRemain: areaSnapshot.sizePixelAtStart + pixels - maxSizePixel,
                };
            }
            return {
                areaSnapshot: areaSnapshot,
                pixelAbsorb: pixels,
                percentAfterAbsorption: tempPercentSize > 100 ? 100 : tempPercentSize,
                pixelRemain: 0,
            };
        }
        // REDUCE AREA
        else if (pixels < 0) {
            // If minSize & newSize smaller than it > absorb to min and return remaining pixels
            if (areaSnapshot.area.minSize !== null && tempPercentSize < areaSnapshot.area.minSize) {
                // Use area.area.minSize as newPercentSize and return calculate pixels remaining
                /** @type {?} */
                var minSizePixel = (areaSnapshot.area.minSize / 100) * allAreasSizePixel;
                return {
                    areaSnapshot: areaSnapshot,
                    pixelAbsorb: minSizePixel,
                    percentAfterAbsorption: areaSnapshot.area.minSize,
                    pixelRemain: areaSnapshot.sizePixelAtStart + pixels - minSizePixel,
                };
            }
            // If reduced under zero > return remaining pixels
            else if (tempPercentSize < 0) {
                // Use 0 as newPercentSize and return calculate pixels remaining
                return {
                    areaSnapshot: areaSnapshot,
                    pixelAbsorb: -areaSnapshot.sizePixelAtStart,
                    percentAfterAbsorption: 0,
                    pixelRemain: pixels + areaSnapshot.sizePixelAtStart,
                };
            }
            return {
                areaSnapshot: areaSnapshot,
                pixelAbsorb: pixels,
                percentAfterAbsorption: tempPercentSize,
                pixelRemain: 0,
            };
        }
    }
    /**
     * @param {?} areaSnapshot
     * @param {?} pixels
     * @param {?} containerSizePixel
     * @return {?}
     */
    function getAreaAbsorptionCapacityPixel(areaSnapshot, pixels, containerSizePixel) {
        /** @type {?} */
        var tempPixelSize = areaSnapshot.sizePixelAtStart + pixels;
        // ENLARGE AREA
        if (pixels > 0) {
            // If maxSize & newSize bigger than it > absorb to max and return remaining pixels
            if (areaSnapshot.area.maxSize !== null && tempPixelSize > areaSnapshot.area.maxSize) {
                return {
                    areaSnapshot: areaSnapshot,
                    pixelAbsorb: areaSnapshot.area.maxSize - areaSnapshot.sizePixelAtStart,
                    percentAfterAbsorption: -1,
                    pixelRemain: tempPixelSize - areaSnapshot.area.maxSize,
                };
            }
            return {
                areaSnapshot: areaSnapshot,
                pixelAbsorb: pixels,
                percentAfterAbsorption: -1,
                pixelRemain: 0,
            };
        }
        // REDUCE AREA
        else if (pixels < 0) {
            // If minSize & newSize smaller than it > absorb to min and return remaining pixels
            if (areaSnapshot.area.minSize !== null && tempPixelSize < areaSnapshot.area.minSize) {
                return {
                    areaSnapshot: areaSnapshot,
                    pixelAbsorb: areaSnapshot.area.minSize + pixels - tempPixelSize,
                    percentAfterAbsorption: -1,
                    pixelRemain: tempPixelSize - areaSnapshot.area.minSize,
                };
            }
            // If reduced under zero > return remaining pixels
            else if (tempPixelSize < 0) {
                return {
                    areaSnapshot: areaSnapshot,
                    pixelAbsorb: -areaSnapshot.sizePixelAtStart,
                    percentAfterAbsorption: -1,
                    pixelRemain: pixels + areaSnapshot.sizePixelAtStart,
                };
            }
            return {
                areaSnapshot: areaSnapshot,
                pixelAbsorb: pixels,
                percentAfterAbsorption: -1,
                pixelRemain: 0,
            };
        }
    }
    /**
     * @param {?} unit
     * @param {?} item
     * @return {?}
     */
    function updateAreaSize(unit, item) {
        if (unit === 'percent') {
            item.areaSnapshot.area.size = item.percentAfterAbsorption;
        }
        else if (unit === 'pixel') {
            // Update size except for the wildcard size area
            if (item.areaSnapshot.area.size !== null) {
                item.areaSnapshot.area.size = item.areaSnapshot.sizePixelAtStart + item.pixelAbsorb;
            }
        }
    }

    /**
     * angular-split
     *
     *
     *  PERCENT MODE ([unit]="'percent'")
     *  ___________________________________________________________________________________________
     * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |
     * |-------------------------------------------------------------------------------------------|
     * |       20                 30                 20                 15                 15      | <-- [size]="x"
     * |               10px               10px               10px               10px               | <-- [gutterSize]="10"
     * |calc(20% - 8px)    calc(30% - 12px)   calc(20% - 8px)    calc(15% - 6px)    calc(15% - 6px)| <-- CSS flex-basis property (with flex-grow&shrink at 0)
     * |     152px              228px              152px              114px              114px     | <-- el.getBoundingClientRect().width
     * |___________________________________________________________________________________________|
     *                                                                                 800px         <-- el.getBoundingClientRect().width
     *  flex-basis = calc( { area.size }% - { area.size/100 * nbGutter*gutterSize }px );
     *
     *
     *  PIXEL MODE ([unit]="'pixel'")
     *  ___________________________________________________________________________________________
     * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |
     * |-------------------------------------------------------------------------------------------|
     * |      100                250                 *                 150                100      | <-- [size]="y"
     * |               10px               10px               10px               10px               | <-- [gutterSize]="10"
     * |   0 0 100px          0 0 250px           1 1 auto          0 0 150px          0 0 100px   | <-- CSS flex property (flex-grow/flex-shrink/flex-basis)
     * |     100px              250px              200px              150px              100px     | <-- el.getBoundingClientRect().width
     * |___________________________________________________________________________________________|
     *                                                                                 800px         <-- el.getBoundingClientRect().width
     *
     */
    var SplitComponent = /** @class */ (function () {
        /**
         * @param {?} ngZone
         * @param {?} elRef
         * @param {?} cdRef
         * @param {?} renderer
         */
        function SplitComponent(ngZone, elRef, cdRef, renderer) {
            this.ngZone = ngZone;
            this.elRef = elRef;
            this.cdRef = cdRef;
            this.renderer = renderer;
            this._direction = 'horizontal';
            this._unit = 'percent';
            this._gutterSize = 11;
            this._gutterStep = 1;
            this._restrictMove = false;
            this._useTransition = false;
            this._disabled = false;
            this._dir = 'ltr';
            this._gutterDblClickDuration = 0;
            this.dragStart = new core.EventEmitter(false);
            this.dragEnd = new core.EventEmitter(false);
            this.gutterClick = new core.EventEmitter(false);
            this.gutterDblClick = new core.EventEmitter(false);
            this.dragProgressSubject = new rxjs.Subject();
            this.dragProgress$ = this.dragProgressSubject.asObservable();
            this.isDragging = false;
            this.isWaitingClear = false;
            this.isWaitingInitialMove = false;
            this.dragListeners = [];
            this.snapshot = null;
            this.startPoint = null;
            this.endPoint = null;
            this.displayedAreas = [];
            this.hiddenAreas = [];
            this._clickTimeout = null;
            // To force adding default class, could be override by user @Input() or not
            this.direction = this._direction;
        }
        Object.defineProperty(SplitComponent.prototype, "direction", {
            /**
             * @return {?}
             */
            get: function () {
                return this._direction;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._direction = v === 'vertical' ? 'vertical' : 'horizontal';
                this.renderer.addClass(this.elRef.nativeElement, "as-" + this._direction);
                this.renderer.removeClass(this.elRef.nativeElement, "as-" + (this._direction === 'vertical' ? 'horizontal' : 'vertical'));
                this.build(false, false);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitComponent.prototype, "unit", {
            /**
             * @return {?}
             */
            get: function () {
                return this._unit;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._unit = v === 'pixel' ? 'pixel' : 'percent';
                this.renderer.addClass(this.elRef.nativeElement, "as-" + this._unit);
                this.renderer.removeClass(this.elRef.nativeElement, "as-" + (this._unit === 'pixel' ? 'percent' : 'pixel'));
                this.build(false, true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitComponent.prototype, "gutterSize", {
            /**
             * @return {?}
             */
            get: function () {
                return this._gutterSize;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._gutterSize = getInputPositiveNumber(v, 11);
                this.build(false, false);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitComponent.prototype, "gutterStep", {
            /**
             * @return {?}
             */
            get: function () {
                return this._gutterStep;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._gutterStep = getInputPositiveNumber(v, 1);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitComponent.prototype, "restrictMove", {
            /**
             * @return {?}
             */
            get: function () {
                return this._restrictMove;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._restrictMove = getInputBoolean(v);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitComponent.prototype, "useTransition", {
            /**
             * @return {?}
             */
            get: function () {
                return this._useTransition;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._useTransition = getInputBoolean(v);
                if (this._useTransition) {
                    this.renderer.addClass(this.elRef.nativeElement, 'as-transition');
                }
                else {
                    this.renderer.removeClass(this.elRef.nativeElement, 'as-transition');
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitComponent.prototype, "disabled", {
            /**
             * @return {?}
             */
            get: function () {
                return this._disabled;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._disabled = getInputBoolean(v);
                if (this._disabled) {
                    this.renderer.addClass(this.elRef.nativeElement, 'as-disabled');
                }
                else {
                    this.renderer.removeClass(this.elRef.nativeElement, 'as-disabled');
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitComponent.prototype, "dir", {
            /**
             * @return {?}
             */
            get: function () {
                return this._dir;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._dir = v === 'rtl' ? 'rtl' : 'ltr';
                this.renderer.setAttribute(this.elRef.nativeElement, 'dir', this._dir);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitComponent.prototype, "gutterDblClickDuration", {
            /**
             * @return {?}
             */
            get: function () {
                return this._gutterDblClickDuration;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._gutterDblClickDuration = getInputPositiveNumber(v, 0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitComponent.prototype, "transitionEnd", {
            /**
             * @return {?}
             */
            get: function () {
                var _this = this;
                return new rxjs.Observable(( /**
                 * @param {?} subscriber
                 * @return {?}
                 */function (subscriber) { return (_this.transitionEndSubscriber = subscriber); })).pipe(operators.debounceTime(20));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        SplitComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(( /**
             * @return {?}
             */function () {
                // To avoid transition at first rendering
                setTimeout(( /**
                 * @return {?}
                 */function () { return _this.renderer.addClass(_this.elRef.nativeElement, 'as-init'); }));
            }));
        };
        /**
         * @private
         * @return {?}
         */
        SplitComponent.prototype.getNbGutters = function () {
            return this.displayedAreas.length === 0 ? 0 : this.displayedAreas.length - 1;
        };
        /**
         * @param {?} component
         * @return {?}
         */
        SplitComponent.prototype.addArea = function (component) {
            /** @type {?} */
            var newArea = {
                component: component,
                order: 0,
                size: 0,
                minSize: null,
                maxSize: null,
                sizeBeforeCollapse: null,
                gutterBeforeCollapse: 0,
            };
            if (component.visible === true) {
                this.displayedAreas.push(newArea);
                this.build(true, true);
            }
            else {
                this.hiddenAreas.push(newArea);
            }
        };
        /**
         * @param {?} component
         * @return {?}
         */
        SplitComponent.prototype.removeArea = function (component) {
            if (this.displayedAreas.some(( /**
             * @param {?} a
             * @return {?}
             */function (a) { return a.component === component; }))) {
                /** @type {?} */
                var area = this.displayedAreas.find(( /**
                 * @param {?} a
                 * @return {?}
                 */function (a) { return a.component === component; }));
                this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);
                this.build(true, true);
            }
            else if (this.hiddenAreas.some(( /**
             * @param {?} a
             * @return {?}
             */function (a) { return a.component === component; }))) {
                /** @type {?} */
                var area = this.hiddenAreas.find(( /**
                 * @param {?} a
                 * @return {?}
                 */function (a) { return a.component === component; }));
                this.hiddenAreas.splice(this.hiddenAreas.indexOf(area), 1);
            }
        };
        /**
         * @param {?} component
         * @param {?} resetOrders
         * @param {?} resetSizes
         * @return {?}
         */
        SplitComponent.prototype.updateArea = function (component, resetOrders, resetSizes) {
            if (component.visible === true) {
                this.build(resetOrders, resetSizes);
            }
        };
        /**
         * @param {?} component
         * @return {?}
         */
        SplitComponent.prototype.showArea = function (component) {
            var _a;
            /** @type {?} */
            var area = this.hiddenAreas.find(( /**
             * @param {?} a
             * @return {?}
             */function (a) { return a.component === component; }));
            if (area === undefined) {
                return;
            }
            /** @type {?} */
            var areas = this.hiddenAreas.splice(this.hiddenAreas.indexOf(area), 1);
            (_a = this.displayedAreas).push.apply(_a, __spread(areas));
            this.build(true, true);
        };
        /**
         * @param {?} comp
         * @return {?}
         */
        SplitComponent.prototype.hideArea = function (comp) {
            var _a;
            /** @type {?} */
            var area = this.displayedAreas.find(( /**
             * @param {?} a
             * @return {?}
             */function (a) { return a.component === comp; }));
            if (area === undefined) {
                return;
            }
            /** @type {?} */
            var areas = this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);
            areas.forEach(( /**
             * @param {?} item
             * @return {?}
             */function (item) {
                item.order = 0;
                item.size = 0;
            }));
            (_a = this.hiddenAreas).push.apply(_a, __spread(areas));
            this.build(true, true);
        };
        /**
         * @return {?}
         */
        SplitComponent.prototype.getVisibleAreaSizes = function () {
            return this.displayedAreas.map(( /**
             * @param {?} a
             * @return {?}
             */function (a) { return (a.size === null ? '*' : a.size); }));
        };
        /**
         * @param {?} sizes
         * @return {?}
         */
        SplitComponent.prototype.setVisibleAreaSizes = function (sizes) {
            if (sizes.length !== this.displayedAreas.length) {
                return false;
            }
            /** @type {?} */
            var formattedSizes = sizes.map(( /**
             * @param {?} s
             * @return {?}
             */function (s) { return getInputPositiveNumber(s, null); }));
            /** @type {?} */
            var isValid = isUserSizesValid(this.unit, formattedSizes);
            if (isValid === false) {
                return false;
            }
            // @ts-ignore
            this.displayedAreas.forEach(( /**
             * @param {?} area
             * @param {?} i
             * @return {?}
             */function (area, i) { return (area.component._size = formattedSizes[i]); }));
            this.build(false, true);
            return true;
        };
        /**
         * @private
         * @param {?} resetOrders
         * @param {?} resetSizes
         * @return {?}
         */
        SplitComponent.prototype.build = function (resetOrders, resetSizes) {
            this.stopDragging();
            // ¤ AREAS ORDER
            if (resetOrders === true) {
                // If user provided 'order' for each area, use it to sort them.
                if (this.displayedAreas.every(( /**
                 * @param {?} a
                 * @return {?}
                 */function (a) { return a.component.order !== null; }))) {
                    this.displayedAreas.sort(( /**
                     * @param {?} a
                     * @param {?} b
                     * @return {?}
                     */function (a, b) { return ( /** @type {?} */(a.component.order)) - ( /** @type {?} */(b.component.order)); }));
                }
                // Then set real order with multiples of 2, numbers between will be used by gutters.
                this.displayedAreas.forEach(( /**
                 * @param {?} area
                 * @param {?} i
                 * @return {?}
                 */function (area, i) {
                    area.order = i * 2;
                    area.component.setStyleOrder(area.order);
                }));
            }
            // ¤ AREAS SIZE
            if (resetSizes === true) {
                /** @type {?} */
                var useUserSizes_1 = isUserSizesValid(this.unit, this.displayedAreas.map(( /**
                 * @param {?} a
                 * @return {?}
                 */function (a) { return a.component.size; })));
                switch (this.unit) {
                    case 'percent': {
                        /** @type {?} */
                        var defaultSize_1 = 100 / this.displayedAreas.length;
                        this.displayedAreas.forEach(( /**
                         * @param {?} area
                         * @return {?}
                         */function (area) {
                            area.size = useUserSizes_1 ? ( /** @type {?} */(area.component.size)) : defaultSize_1;
                            area.minSize = getAreaMinSize(area);
                            area.maxSize = getAreaMaxSize(area);
                        }));
                        break;
                    }
                    case 'pixel': {
                        if (useUserSizes_1) {
                            this.displayedAreas.forEach(( /**
                             * @param {?} area
                             * @return {?}
                             */function (area) {
                                area.size = area.component.size;
                                area.minSize = getAreaMinSize(area);
                                area.maxSize = getAreaMaxSize(area);
                            }));
                        }
                        else {
                            /** @type {?} */
                            var wildcardSizeAreas = this.displayedAreas.filter(( /**
                             * @param {?} a
                             * @return {?}
                             */function (a) { return a.component.size === null; }));
                            // No wildcard area > Need to select one arbitrarily > first
                            if (wildcardSizeAreas.length === 0 && this.displayedAreas.length > 0) {
                                this.displayedAreas.forEach(( /**
                                 * @param {?} area
                                 * @param {?} i
                                 * @return {?}
                                 */function (area, i) {
                                    area.size = i === 0 ? null : area.component.size;
                                    area.minSize = i === 0 ? null : getAreaMinSize(area);
                                    area.maxSize = i === 0 ? null : getAreaMaxSize(area);
                                }));
                            }
                            else if (wildcardSizeAreas.length > 1) {
                                // More than one wildcard area > Need to keep only one arbitrarily > first
                                /** @type {?} */
                                var alreadyGotOne_1 = false;
                                this.displayedAreas.forEach(( /**
                                 * @param {?} area
                                 * @return {?}
                                 */function (area) {
                                    if (area.component.size === null) {
                                        if (alreadyGotOne_1 === false) {
                                            area.size = null;
                                            area.minSize = null;
                                            area.maxSize = null;
                                            alreadyGotOne_1 = true;
                                        }
                                        else {
                                            area.size = 100;
                                            area.minSize = null;
                                            area.maxSize = null;
                                        }
                                    }
                                    else {
                                        area.size = area.component.size;
                                        area.minSize = getAreaMinSize(area);
                                        area.maxSize = getAreaMaxSize(area);
                                    }
                                }));
                            }
                        }
                        break;
                    }
                }
            }
            this.refreshStyleSizes();
            this.cdRef.markForCheck();
        };
        /**
         * @private
         * @return {?}
         */
        SplitComponent.prototype.refreshStyleSizes = function () {
            var _this = this;
            ///////////////////////////////////////////
            // PERCENT MODE
            if (this.unit === 'percent') {
                // Only one area > flex-basis 100%
                if (this.displayedAreas.length === 1) {
                    this.displayedAreas[0].component.setStyleFlex(0, 0, "100%", false, false);
                }
                else {
                    // Multiple areas > use each percent basis
                    /** @type {?} */
                    var sumGutterSize_1 = this.getNbGutters() * this.gutterSize;
                    this.displayedAreas.forEach(( /**
                     * @param {?} area
                     * @return {?}
                     */function (area) {
                        area.component.setStyleFlex(0, 0, "calc( " + area.size + "% - " + (( /** @type {?} */(area.size)) / 100) * sumGutterSize_1 + "px )", area.minSize !== null && area.minSize === area.size, area.maxSize !== null && area.maxSize === area.size);
                    }));
                }
            }
            else if (this.unit === 'pixel') {
                ///////////////////////////////////////////
                // PIXEL MODE
                this.displayedAreas.forEach(( /**
                 * @param {?} area
                 * @return {?}
                 */function (area) {
                    // Area with wildcard size
                    if (area.size === null) {
                        if (_this.displayedAreas.length === 1) {
                            area.component.setStyleFlex(1, 1, "100%", false, false);
                        }
                        else {
                            area.component.setStyleFlex(1, 1, "auto", false, false);
                        }
                    }
                    else {
                        // Area with pixel size
                        // Only one area > flex-basis 100%
                        if (_this.displayedAreas.length === 1) {
                            area.component.setStyleFlex(0, 0, "100%", false, false);
                        }
                        else {
                            // Multiple areas > use each pixel basis
                            area.component.setStyleFlex(0, 0, area.size + "px", area.minSize !== null && area.minSize === area.size, area.maxSize !== null && area.maxSize === area.size);
                        }
                    }
                }));
            }
        };
        /**
         * @param {?} event
         * @param {?} gutterNum
         * @return {?}
         */
        SplitComponent.prototype.clickGutter = function (event, gutterNum) {
            var _this = this;
            /** @type {?} */
            var tempPoint = getPointFromEvent(event);
            // Be sure mouseup/touchend happened if touch/cursor is not moved.
            if (this.startPoint &&
                this.startPoint.x === tempPoint.x &&
                this.startPoint.y === tempPoint.y &&
                (!this.isDragging || this.isWaitingInitialMove)) {
                // If timeout in progress and new click > clearTimeout & dblClickEvent
                if (this._clickTimeout !== null) {
                    window.clearTimeout(this._clickTimeout);
                    this._clickTimeout = null;
                    this.notify('dblclick', gutterNum);
                    this.stopDragging();
                }
                else {
                    // Else start timeout to call clickEvent at end
                    this._clickTimeout = window.setTimeout(( /**
                     * @return {?}
                     */function () {
                        _this._clickTimeout = null;
                        _this.notify('click', gutterNum);
                        _this.stopDragging();
                    }), this.gutterDblClickDuration);
                }
            }
        };
        /**
         * @param {?} event
         * @param {?} gutterOrder
         * @param {?} gutterNum
         * @return {?}
         */
        SplitComponent.prototype.startDragging = function (event, gutterOrder, gutterNum) {
            var _this = this;
            event.preventDefault();
            event.stopPropagation();
            this.startPoint = getPointFromEvent(event);
            if (this.startPoint === null || this.disabled === true || this.isWaitingClear === true) {
                return;
            }
            this.snapshot = {
                gutterNum: gutterNum,
                lastSteppedOffset: 0,
                allAreasSizePixel: getElementPixelSize(this.elRef, this.direction) - this.getNbGutters() * this.gutterSize,
                allInvolvedAreasSizePercent: 100,
                areasBeforeGutter: [],
                areasAfterGutter: [],
            };
            this.displayedAreas.forEach(( /**
             * @param {?} area
             * @return {?}
             */function (area) {
                /** @type {?} */
                var areaSnapshot = {
                    area: area,
                    sizePixelAtStart: getElementPixelSize(area.component.elRef, _this.direction),
                    sizePercentAtStart: _this.unit === 'percent' ? area.size : -1,
                };
                if (area.order < gutterOrder) {
                    if (_this.restrictMove === true) {
                        _this.snapshot.areasBeforeGutter = [areaSnapshot];
                    }
                    else {
                        _this.snapshot.areasBeforeGutter.unshift(areaSnapshot);
                    }
                }
                else if (area.order > gutterOrder) {
                    if (_this.restrictMove === true) {
                        if (_this.snapshot.areasAfterGutter.length === 0) {
                            _this.snapshot.areasAfterGutter = [areaSnapshot];
                        }
                    }
                    else {
                        _this.snapshot.areasAfterGutter.push(areaSnapshot);
                    }
                }
            }));
            this.snapshot.allInvolvedAreasSizePercent = __spread(this.snapshot.areasBeforeGutter, this.snapshot.areasAfterGutter).reduce(( /**
             * @param {?} t
             * @param {?} a
             * @return {?}
             */function (t, a) { return t + a.sizePercentAtStart; }), 0);
            if (this.snapshot.areasBeforeGutter.length === 0 || this.snapshot.areasAfterGutter.length === 0) {
                return;
            }
            this.dragListeners.push(this.renderer.listen('document', 'mouseup', this.stopDragging.bind(this)));
            this.dragListeners.push(this.renderer.listen('document', 'touchend', this.stopDragging.bind(this)));
            this.dragListeners.push(this.renderer.listen('document', 'touchcancel', this.stopDragging.bind(this)));
            this.ngZone.runOutsideAngular(( /**
             * @return {?}
             */function () {
                _this.dragListeners.push(_this.renderer.listen('document', 'mousemove', _this.dragEvent.bind(_this)));
                _this.dragListeners.push(_this.renderer.listen('document', 'touchmove', _this.dragEvent.bind(_this)));
            }));
            this.displayedAreas.forEach(( /**
             * @param {?} area
             * @return {?}
             */function (area) { return area.component.lockEvents(); }));
            this.isDragging = true;
            this.isWaitingInitialMove = true;
        };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        SplitComponent.prototype.dragEvent = function (event) {
            var _this = this;
            event.preventDefault();
            event.stopPropagation();
            if (this._clickTimeout !== null) {
                window.clearTimeout(this._clickTimeout);
                this._clickTimeout = null;
            }
            if (this.isDragging === false) {
                return;
            }
            this.endPoint = getPointFromEvent(event);
            if (this.endPoint === null) {
                return;
            }
            if (this.isWaitingInitialMove) {
                if (this.startPoint.x !== this.endPoint.x || this.startPoint.y !== this.endPoint.y) {
                    this.ngZone.run(( /**
                     * @return {?}
                     */function () {
                        _this.isWaitingInitialMove = false;
                        _this.renderer.addClass(_this.elRef.nativeElement, 'as-dragging');
                        _this.renderer.addClass(_this.gutterEls.toArray()[_this.snapshot.gutterNum - 1].nativeElement, 'as-dragged');
                        _this.notify('start', _this.snapshot.gutterNum);
                    }));
                }
                else {
                    return;
                }
            }
            // Calculate steppedOffset
            /** @type {?} */
            var offset = this.direction === 'horizontal' ? this.startPoint.x - this.endPoint.x : this.startPoint.y - this.endPoint.y;
            if (this.dir === 'rtl') {
                offset = -offset;
            }
            /** @type {?} */
            var steppedOffset = Math.round(offset / this.gutterStep) * this.gutterStep;
            if (steppedOffset === this.snapshot.lastSteppedOffset) {
                return;
            }
            this.snapshot.lastSteppedOffset = steppedOffset;
            // Need to know if each gutter side areas could reacts to steppedOffset
            /** @type {?} */
            var areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -steppedOffset, this.snapshot.allAreasSizePixel);
            /** @type {?} */
            var areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset, this.snapshot.allAreasSizePixel);
            // Each gutter side areas can't absorb all offset
            if (areasBefore.remain !== 0 && areasAfter.remain !== 0) {
                if (Math.abs(areasBefore.remain) === Math.abs(areasAfter.remain)) {
                }
                else if (Math.abs(areasBefore.remain) > Math.abs(areasAfter.remain)) {
                    areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset + areasBefore.remain, this.snapshot.allAreasSizePixel);
                }
                else {
                    areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -(steppedOffset - areasAfter.remain), this.snapshot.allAreasSizePixel);
                }
            }
            else if (areasBefore.remain !== 0) {
                // Areas before gutter can't absorbs all offset > need to recalculate sizes for areas after gutter.
                areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset + areasBefore.remain, this.snapshot.allAreasSizePixel);
            }
            else if (areasAfter.remain !== 0) {
                // Areas after gutter can't absorbs all offset > need to recalculate sizes for areas before gutter.
                areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -(steppedOffset - areasAfter.remain), this.snapshot.allAreasSizePixel);
            }
            if (this.unit === 'percent') {
                // Hack because of browser messing up with sizes using calc(X% - Ypx) -> el.getBoundingClientRect()
                // If not there, playing with gutters makes total going down to 99.99875% then 99.99286%, 99.98986%,..
                /** @type {?} */
                var all = __spread(areasBefore.list, areasAfter.list);
                /** @type {?} */
                var areaToReset_1 = all.find(( /**
                 * @param {?} a
                 * @return {?}
                 */function (a) { return a.percentAfterAbsorption !== 0 &&
                    a.percentAfterAbsorption !== a.areaSnapshot.area.minSize &&
                    a.percentAfterAbsorption !== a.areaSnapshot.area.maxSize; }));
                if (areaToReset_1) {
                    areaToReset_1.percentAfterAbsorption =
                        this.snapshot.allInvolvedAreasSizePercent -
                            all.filter(( /**
                             * @param {?} a
                             * @return {?}
                             */function (a) { return a !== areaToReset_1; })).reduce(( /**
                             * @param {?} total
                             * @param {?} a
                             * @return {?}
                             */function (total, a) { return total + a.percentAfterAbsorption; }), 0);
                }
            }
            // Now we know areas could absorb steppedOffset, time to really update sizes
            areasBefore.list.forEach(( /**
             * @param {?} item
             * @return {?}
             */function (item) { return updateAreaSize(_this.unit, item); }));
            areasAfter.list.forEach(( /**
             * @param {?} item
             * @return {?}
             */function (item) { return updateAreaSize(_this.unit, item); }));
            this.refreshStyleSizes();
            this.notify('progress', this.snapshot.gutterNum);
        };
        /**
         * @private
         * @param {?=} event
         * @return {?}
         */
        SplitComponent.prototype.stopDragging = function (event) {
            var _this = this;
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (this.isDragging === false) {
                return;
            }
            this.displayedAreas.forEach(( /**
             * @param {?} area
             * @return {?}
             */function (area) { return area.component.unlockEvents(); }));
            while (this.dragListeners.length > 0) {
                /** @type {?} */
                var fct = this.dragListeners.pop();
                if (fct) {
                    fct();
                }
            }
            // Warning: Have to be before "notify('end')"
            // because "notify('end')"" can be linked to "[size]='x'" > "build()" > "stopDragging()"
            this.isDragging = false;
            // If moved from starting point, notify end
            if (this.isWaitingInitialMove === false) {
                this.notify('end', this.snapshot.gutterNum);
            }
            this.renderer.removeClass(this.elRef.nativeElement, 'as-dragging');
            this.renderer.removeClass(this.gutterEls.toArray()[this.snapshot.gutterNum - 1].nativeElement, 'as-dragged');
            this.snapshot = null;
            this.isWaitingClear = true;
            // Needed to let (click)="clickGutter(...)" event run and verify if mouse moved or not
            this.ngZone.runOutsideAngular(( /**
             * @return {?}
             */function () {
                setTimeout(( /**
                 * @return {?}
                 */function () {
                    _this.startPoint = null;
                    _this.endPoint = null;
                    _this.isWaitingClear = false;
                }));
            }));
        };
        /**
         * @param {?} type
         * @param {?} gutterNum
         * @return {?}
         */
        SplitComponent.prototype.notify = function (type, gutterNum) {
            var _this = this;
            /** @type {?} */
            var sizes = this.getVisibleAreaSizes();
            if (type === 'start') {
                this.dragStart.emit({ gutterNum: gutterNum, sizes: sizes });
            }
            else if (type === 'end') {
                this.dragEnd.emit({ gutterNum: gutterNum, sizes: sizes });
            }
            else if (type === 'click') {
                this.gutterClick.emit({ gutterNum: gutterNum, sizes: sizes });
            }
            else if (type === 'dblclick') {
                this.gutterDblClick.emit({ gutterNum: gutterNum, sizes: sizes });
            }
            else if (type === 'transitionEnd') {
                if (this.transitionEndSubscriber) {
                    this.ngZone.run(( /**
                     * @return {?}
                     */function () { return _this.transitionEndSubscriber.next(sizes); }));
                }
            }
            else if (type === 'progress') {
                // Stay outside zone to allow users do what they want about change detection mechanism.
                this.dragProgressSubject.next({ gutterNum: gutterNum, sizes: sizes });
            }
        };
        /**
         * @return {?}
         */
        SplitComponent.prototype.ngOnDestroy = function () {
            this.stopDragging();
        };
        /**
         * @param {?} comp
         * @param {?} newSize
         * @param {?} gutter
         * @return {?}
         */
        SplitComponent.prototype.collapseArea = function (comp, newSize, gutter) {
            /** @type {?} */
            var area = this.displayedAreas.find(( /**
             * @param {?} a
             * @return {?}
             */function (a) { return a.component === comp; }));
            if (area === undefined) {
                return;
            }
            /** @type {?} */
            var whichGutter = gutter === 'right' ? 1 : -1;
            if (!area.sizeBeforeCollapse) {
                area.sizeBeforeCollapse = area.size;
                area.gutterBeforeCollapse = whichGutter;
            }
            area.size = newSize;
            /** @type {?} */
            var gtr = this.gutterEls.find(( /**
             * @param {?} f
             * @return {?}
             */function (f) { return f.nativeElement.style.order === "" + (area.order + whichGutter); }));
            if (gtr) {
                this.renderer.addClass(gtr.nativeElement, 'as-split-gutter-collapsed');
            }
            this.updateArea(comp, false, false);
        };
        /**
         * @param {?} comp
         * @return {?}
         */
        SplitComponent.prototype.expandArea = function (comp) {
            /** @type {?} */
            var area = this.displayedAreas.find(( /**
             * @param {?} a
             * @return {?}
             */function (a) { return a.component === comp; }));
            if (area === undefined) {
                return;
            }
            if (!area.sizeBeforeCollapse) {
                return;
            }
            area.size = area.sizeBeforeCollapse;
            area.sizeBeforeCollapse = null;
            /** @type {?} */
            var gtr = this.gutterEls.find(( /**
             * @param {?} f
             * @return {?}
             */function (f) { return f.nativeElement.style.order === "" + (area.order + area.gutterBeforeCollapse); }));
            if (gtr) {
                this.renderer.removeClass(gtr.nativeElement, 'as-split-gutter-collapsed');
            }
            this.updateArea(comp, false, false);
        };
        return SplitComponent;
    }());
    SplitComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'as-split',
                    exportAs: 'asSplit',
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    template: " <ng-content></ng-content>\n    <ng-template ngFor [ngForOf]=\"displayedAreas\" let-index=\"index\" let-last=\"last\">\n      <div\n        *ngIf=\"last === false\"\n        #gutterEls\n        class=\"as-split-gutter\"\n        [style.flex-basis.px]=\"gutterSize\"\n        [style.order]=\"index * 2 + 1\"\n        (mousedown)=\"startDragging($event, index * 2 + 1, index + 1)\"\n        (touchstart)=\"startDragging($event, index * 2 + 1, index + 1)\"\n        (mouseup)=\"clickGutter($event, index + 1)\"\n        (touchend)=\"clickGutter($event, index + 1)\"\n      >\n        <div class=\"as-split-gutter-icon\"></div>\n      </div>\n    </ng-template>",
                    encapsulation: core.ViewEncapsulation.Emulated,
                    styles: [":host{align-items:stretch;display:flex;flex-wrap:nowrap;height:100%;justify-content:flex-start;overflow:hidden;width:100%}:host>.as-split-gutter{align-items:center;background-color:#eee;display:flex;flex-grow:0;flex-shrink:0;justify-content:center}:host>.as-split-gutter.as-split-gutter-collapsed{flex-basis:1px!important;pointer-events:none}:host>.as-split-gutter>.as-split-gutter-icon{background-position:50%;background-repeat:no-repeat;height:100%;width:100%}:host ::ng-deep>.as-split-area{flex-grow:0;flex-shrink:0;overflow-x:hidden;overflow-y:auto}:host ::ng-deep>.as-split-area.as-hidden{flex:0 1 0px!important;overflow-x:hidden;overflow-y:hidden}:host.as-horizontal{flex-direction:row}:host.as-horizontal>.as-split-gutter{cursor:col-resize;flex-direction:row;height:100%}:host.as-horizontal>.as-split-gutter>.as-split-gutter-icon{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==\")}:host.as-horizontal ::ng-deep>.as-split-area{height:100%}:host.as-vertical{flex-direction:column}:host.as-vertical>.as-split-gutter{cursor:row-resize;flex-direction:column;width:100%}:host.as-vertical>.as-split-gutter .as-split-gutter-icon{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFCAMAAABl/6zIAAAABlBMVEUAAADMzMzIT8AyAAAAAXRSTlMAQObYZgAAABRJREFUeAFjYGRkwIMJSeMHlBkOABP7AEGzSuPKAAAAAElFTkSuQmCC\")}:host.as-vertical ::ng-deep>.as-split-area{width:100%}:host.as-vertical ::ng-deep>.as-split-area.as-hidden{max-width:0}:host.as-disabled>.as-split-gutter{cursor:default}:host.as-disabled>.as-split-gutter .as-split-gutter-icon{background-image:url()}:host.as-transition.as-init:not(.as-dragging) ::ng-deep>.as-split-area,:host.as-transition.as-init:not(.as-dragging)>.as-split-gutter{transition:flex-basis .3s}"]
                }] }
    ];
    /** @nocollapse */
    SplitComponent.ctorParameters = function () { return [
        { type: core.NgZone },
        { type: core.ElementRef },
        { type: core.ChangeDetectorRef },
        { type: core.Renderer2 }
    ]; };
    SplitComponent.propDecorators = {
        direction: [{ type: core.Input }],
        unit: [{ type: core.Input }],
        gutterSize: [{ type: core.Input }],
        gutterStep: [{ type: core.Input }],
        restrictMove: [{ type: core.Input }],
        useTransition: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        dir: [{ type: core.Input }],
        gutterDblClickDuration: [{ type: core.Input }],
        transitionEnd: [{ type: core.Output }],
        dragStart: [{ type: core.Output }],
        dragEnd: [{ type: core.Output }],
        gutterClick: [{ type: core.Output }],
        gutterDblClick: [{ type: core.Output }],
        gutterEls: [{ type: core.ViewChildren, args: ['gutterEls',] }]
    };
    if (false) {
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype._direction;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype._unit;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype._gutterSize;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype._gutterStep;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype._restrictMove;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype._useTransition;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype._dir;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype._gutterDblClickDuration;
        /** @type {?} */
        SplitComponent.prototype.dragStart;
        /** @type {?} */
        SplitComponent.prototype.dragEnd;
        /** @type {?} */
        SplitComponent.prototype.gutterClick;
        /** @type {?} */
        SplitComponent.prototype.gutterDblClick;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.transitionEndSubscriber;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.dragProgressSubject;
        /** @type {?} */
        SplitComponent.prototype.dragProgress$;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.isDragging;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.isWaitingClear;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.isWaitingInitialMove;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.dragListeners;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.snapshot;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.startPoint;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.endPoint;
        /** @type {?} */
        SplitComponent.prototype.displayedAreas;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.hiddenAreas;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.gutterEls;
        /** @type {?} */
        SplitComponent.prototype._clickTimeout;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.ngZone;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.elRef;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.cdRef;
        /**
         * @type {?}
         * @private
         */
        SplitComponent.prototype.renderer;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directive/split-area.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SplitAreaDirective = /** @class */ (function () {
        /**
         * @param {?} ngZone
         * @param {?} elRef
         * @param {?} renderer
         * @param {?} split
         */
        function SplitAreaDirective(ngZone, elRef, renderer, split) {
            this.ngZone = ngZone;
            this.elRef = elRef;
            this.renderer = renderer;
            this.split = split;
            this._order = null;
            this._size = null;
            this._minSize = null;
            this._maxSize = null;
            this._lockSize = false;
            this._visible = true;
            this.lockListeners = [];
            this.renderer.addClass(this.elRef.nativeElement, 'as-split-area');
        }
        Object.defineProperty(SplitAreaDirective.prototype, "order", {
            /**
             * @return {?}
             */
            get: function () {
                return this._order;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._order = getInputPositiveNumber(v, null);
                this.split.updateArea(this, true, false);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitAreaDirective.prototype, "size", {
            /**
             * @return {?}
             */
            get: function () {
                return this._size;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._size = getInputPositiveNumber(v, null);
                this.split.updateArea(this, false, true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitAreaDirective.prototype, "minSize", {
            /**
             * @return {?}
             */
            get: function () {
                return this._minSize;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._minSize = getInputPositiveNumber(v, null);
                this.split.updateArea(this, false, true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitAreaDirective.prototype, "maxSize", {
            /**
             * @return {?}
             */
            get: function () {
                return this._maxSize;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._maxSize = getInputPositiveNumber(v, null);
                this.split.updateArea(this, false, true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitAreaDirective.prototype, "lockSize", {
            /**
             * @return {?}
             */
            get: function () {
                return this._lockSize;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._lockSize = getInputBoolean(v);
                this.split.updateArea(this, false, true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SplitAreaDirective.prototype, "visible", {
            /**
             * @return {?}
             */
            get: function () {
                return this._visible;
            },
            /**
             * @param {?} v
             * @return {?}
             */
            set: function (v) {
                this._visible = getInputBoolean(v);
                if (this._visible) {
                    this.split.showArea(this);
                    this.renderer.removeClass(this.elRef.nativeElement, 'as-hidden');
                }
                else {
                    this.split.hideArea(this);
                    this.renderer.addClass(this.elRef.nativeElement, 'as-hidden');
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        SplitAreaDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.split.addArea(this);
            this.ngZone.runOutsideAngular(( /**
             * @return {?}
             */function () {
                _this.transitionListener = _this.renderer.listen(_this.elRef.nativeElement, 'transitionend', ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    // Limit only flex-basis transition to trigger the event
                    if (event.propertyName === 'flex-basis') {
                        _this.split.notify('transitionEnd', -1);
                    }
                }));
            }));
        };
        /**
         * @param {?} value
         * @return {?}
         */
        SplitAreaDirective.prototype.setStyleOrder = function (value) {
            this.renderer.setStyle(this.elRef.nativeElement, 'order', value);
        };
        /**
         * @param {?} grow
         * @param {?} shrink
         * @param {?} basis
         * @param {?} isMin
         * @param {?} isMax
         * @return {?}
         */
        SplitAreaDirective.prototype.setStyleFlex = function (grow, shrink, basis, isMin, isMax) {
            // Need 3 separated properties to work on IE11 (https://github.com/angular/flex-layout/issues/323)
            this.renderer.setStyle(this.elRef.nativeElement, 'flex-grow', grow);
            this.renderer.setStyle(this.elRef.nativeElement, 'flex-shrink', shrink);
            this.renderer.setStyle(this.elRef.nativeElement, 'flex-basis', basis);
            if (isMin === true) {
                this.renderer.addClass(this.elRef.nativeElement, 'as-min');
            }
            else {
                this.renderer.removeClass(this.elRef.nativeElement, 'as-min');
            }
            if (isMax === true) {
                this.renderer.addClass(this.elRef.nativeElement, 'as-max');
            }
            else {
                this.renderer.removeClass(this.elRef.nativeElement, 'as-max');
            }
        };
        /**
         * @return {?}
         */
        SplitAreaDirective.prototype.lockEvents = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(( /**
             * @return {?}
             */function () {
                _this.lockListeners.push(_this.renderer.listen(_this.elRef.nativeElement, 'selectstart', ( /**
                 * @return {?}
                 */function () { return false; })));
                _this.lockListeners.push(_this.renderer.listen(_this.elRef.nativeElement, 'dragstart', ( /**
                 * @return {?}
                 */function () { return false; })));
            }));
        };
        /**
         * @return {?}
         */
        SplitAreaDirective.prototype.unlockEvents = function () {
            while (this.lockListeners.length > 0) {
                /** @type {?} */
                var fct = this.lockListeners.pop();
                if (fct) {
                    fct();
                }
            }
        };
        /**
         * @return {?}
         */
        SplitAreaDirective.prototype.ngOnDestroy = function () {
            this.unlockEvents();
            if (this.transitionListener) {
                this.transitionListener();
            }
            this.split.removeArea(this);
        };
        /**
         * @param {?=} newSize
         * @param {?=} gutter
         * @return {?}
         */
        SplitAreaDirective.prototype.collapse = function (newSize, gutter) {
            if (newSize === void 0) { newSize = 0; }
            if (gutter === void 0) { gutter = 'right'; }
            this.split.collapseArea(this, newSize, gutter);
        };
        /**
         * @return {?}
         */
        SplitAreaDirective.prototype.expand = function () {
            this.split.expandArea(this);
        };
        return SplitAreaDirective;
    }());
    SplitAreaDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: 'as-split-area, [as-split-area]',
                    exportAs: 'asSplitArea',
                },] }
    ];
    /** @nocollapse */
    SplitAreaDirective.ctorParameters = function () { return [
        { type: core.NgZone },
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: SplitComponent }
    ]; };
    SplitAreaDirective.propDecorators = {
        order: [{ type: core.Input }],
        size: [{ type: core.Input }],
        minSize: [{ type: core.Input }],
        maxSize: [{ type: core.Input }],
        lockSize: [{ type: core.Input }],
        visible: [{ type: core.Input }]
    };
    if (false) {
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype._order;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype._size;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype._minSize;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype._maxSize;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype._lockSize;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype._visible;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype.transitionListener;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype.lockListeners;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype.ngZone;
        /** @type {?} */
        SplitAreaDirective.prototype.elRef;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype.renderer;
        /**
         * @type {?}
         * @private
         */
        SplitAreaDirective.prototype.split;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AngularSplitModule = /** @class */ (function () {
        function AngularSplitModule() {
        }
        /**
         * @return {?}
         */
        AngularSplitModule.forRoot = function () {
            console.warn("AngularSplitModule.forRoot() is deprecated and will be removed in v6");
            return {
                ngModule: AngularSplitModule,
                providers: [],
            };
        };
        /**
         * @return {?}
         */
        AngularSplitModule.forChild = function () {
            console.warn("AngularSplitModule.forChild() is deprecated and will be removed in v6");
            return {
                ngModule: AngularSplitModule,
                providers: [],
            };
        };
        return AngularSplitModule;
    }());
    AngularSplitModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [SplitComponent, SplitAreaDirective],
                    exports: [SplitComponent, SplitAreaDirective],
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: angular-split.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.AngularSplitModule = AngularSplitModule;
    exports.SplitAreaDirective = SplitAreaDirective;
    exports.SplitComponent = SplitComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-split.umd.js.map
